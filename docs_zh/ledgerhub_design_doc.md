# LedgerHub 设计文档<a id="title"></a>

[<u>Martin Blais</u>](mailto:blais@furius.ca)，2014年2月

[<u>http://furius.ca/beancount/doc/ledgerhub-design-doc</u>](http://furius.ca/beancount/doc/ledgerhub-design-doc)

> [<u>动机</u>](#motivation)
>
> [<u>目标和阶段</u>](#goals-stages)
>
> [<u>阶段详细信息</u>](#details-of-stages)
>
> [<u>获取数据</u>](#fetching)
>
> [<u>识别</u>](#identification)
>
> [<u>提取</u>](#extraction)
>
> [<u>转换</u>](#transform)
>
> [<u>呈现</u>](#rendering)
>
> [<u>归档</u>](#filing)
>
> [<u>实现细节</u>](#implementation-details)
>
> [<u>导入器接口</u>](#importers-interface)
>
> [<u>参考文献</u>](#references)

***请注意，这是 LedgerHub 的原始设计文档。LedgerHub 正在重新整合到 Beancount 中。有关详情，请参阅[<u>事后分析文档</u>](https://docs.google.com/document/d/1Bln8Zo11Cvez2rdEgpnM-oBHC1B6uPC18Qm7ulobolM/) [blais，2015-12]。***

## 动机<a id="motivation"></a>

目前存在几个开源项目，这些项目提供了从文本文件输入创建复式记账交易的功能。这些不同的复式记账项目包括 [<u>Beancount</u>](http://furius.ca/beancount/)、[<u>Ledger</u>](http://ledger-cli.org/)、[<u>HLedger</u>](http://hledger.org/)、[<u>Abandon</u>](https://github.com/hrj/abandon)，它们都是为了实现类似的目标：从文本文件中创建复式记账交易的内存表示，并从中生成各种报告，如资产负债表、损益表、日记账等。每个实现探索略有不同的功能集，但基本上都是通过从文件中读取输入，其格式是描述交易的自定义声明性语言，这种语言旨在由人类编写，语法设计时考虑了这一点。虽然语言有所不同，但它们定义的底层数据结构非常相似。

定期更新个人日记账文件的一个重要部分是将实际账户的交易明细复制到一个一致的数据格式的单个输入文件中。这本质上是一个翻译步骤，旨在将许多机构账户的交易明细整合到一个系统中。各种银行和信用卡公司提供的下载交易数据格式有 Quicken 或 Microsoft Money (OFX) 格式，许多机构提供自定义的 CSV 文件。此外，许多这些机构还提供定期对账单的 PDF 文件下载，这些文件可以与个人的账簿账户相关联。

翻译这些外部数据格式的过程可以在一定程度上自动化。这些文件可以被翻译为输出文本，然后用户可以对其进行处理，以集成到复式记账软件包接受的输入文件格式中。几个项目已经在这个领域有所进展：[<u>Ledger-autosync</u>](https://pypi.python.org/pypi/ledger-autosync/) 旨在自动从 OFX 服务器获取交易并为 Ledger 和 HLedger 翻译它们，[<u>Reckon</u>](https://github.com/cantino/reckon) 将 CSV 文件转换为 Ledger。 [<u>Beancount</u>](http://furius.ca/beancount/) 包含可以自动识别下载文件到账簿账户的代码，提取其交易明细，并将其自动归档到与账簿的账户结构对应的目录层次结构中。此代码可能应该存在于 Beancount 之外。[<u>Ledger</u>](http://ledger-cli.org/) 还提供一个“convert”命令，尝试做类似的事情，并且有一个 [<u>CSV2Ledger</u>](https://github.com/jwiegley/CSV2Ledger) Perl 脚本可以转换 CSV 文件。HLedger 也有一个转换命令，它使用可选的转换提示文件将 CSV 文件转换；HLedger 现在 [<u>在输入文件为 CSV 时即时进行相同的转换</u>](http://hledger.org/manual#csv-files)（即 CSV 被认为是一级输入格式）。

获取和转换外部数据文件的程序不必绑定到单一系统。此外，这通常是繁琐的代码，如果有大量贡献者受益于共同的解析器来处理他们使用或可能使用的各种机构的文件，这将极大地受益。我（Beancount 的作者）决定将 Beancount 的导入和归档源代码移出其主项目，并与 Beancount 源代码解耦，以便其他人可以贡献其中的代码，意图是提供项目无关的功能。本文档描述了该项目的目标和设计。

## 目标和阶段<a id="goals-stages"></a>

这个新项目应该以项目无关的方式解决以下方面：

- **获取数据**：通过直接连接到数据源来自动*获取*外部数据文件。可以利用外部工具和库，例如 [<u>ofxclient</u>](https://github.com/captin411/ofxclient) 获取 OFX 源数据。可以在可能的情况下使用网络爬虫来获取可下载文件。此阶段的输出是下载到目录中的特定机构文件列表。  
  注意，这里的获取不仅适用于交易数据；我们还将支持获取*价格*。可以从这些数据创建（日期，价格）条目列表。我们可能希望支持一种中间格式，用于表示持仓列表（以及在 ledgerhub-Ledger/Beancount/HLedger 接口中提供适当支持以获取它）。

- **识别**：给定文件名及其内容，自动*猜测*文件对应的机构和账户配置，并理想情况下能够从文件或对账单中提取日期。这也应该适用于 PDF 文件。此阶段的输出是每个输入文件与特定提取器和配置（例如特定账户名称）的关联。

- **提取**：*解析每个文件*（如果可能）并从中提取生成复式记账交易数据结构所需的信息列表，以某种*通用*数据结构表示，例如字符串和数字的字典，独立于底层项目的预期输出。如果可能，应将生成交易的原始文本片段附加到输出数据结构中。此阶段的输出是一个数据结构，例如定义格式的 Python 字典列表。

- **转换**：给定日记账中包含的历史交易信息，使用简单的学习算法，程序应该能够对从上一步提取的交易信息应用转换。最常见的用例是自动为仅有一个分录的交易添加分类分录。例如，信用卡对账单中的交易通常包括信用卡账户余额的变化，但所有交易都需要手动关联到特定的费用账户。在此阶段可以自动化此过程。

<!-- -->

- **呈现**：将内部交易数据结构转换为特定复式记账项目实现的语法和特定的预期语法变体（例如货币格式、逗号与点的小数分隔符、本地化的输入日期格式）。此步骤输出要插入到所选账簿软件兼容的输入文件中的文本。

- **归档**：清理下载文件的文件名，并将其移动到与识别步骤确定的账户对应的有组织的目录层次结构中。

除了呈现阶段，所有其他阶段都应该在不考虑特定项目的情况下实现，这应该适用于所有账簿实现。然而，呈现代码应该专门化，导入源代码，并尝试为每个项目提供尽可能多的特定功能到其输出文本。

在必要时，应提供接口以从每个账簿实现的输入文件中获取特定数据集，以屏蔽该项目的特定实现细节。例如，分类转换步骤需要在某些交易数据上训练其算法（即叙述字段，也许还有一些金额、账户名称和日期）。每个项目应提供一种方法，从其输入数据文件中获取必要的数据，以相同的格式。

## 阶段详细信息<a id="details-of-stages"></a>

### 获取数据<a id="fetching"></a>

默认情况下，用户应该能够点击其机构网站并将文档下载到其 ~/Downloads 目录。一个包含一些文件的目录应该是识别阶段的合理默认输入。此目录应该允许包含其他/垃圾文件，识别步骤应该能够自动跳过这些文件。

需要实现一个可以自动获取数据的模块。理想情况下，这不需要外部工具。提取的数据也应该保存在某个 Downloads 目录中。

这是 ledger-autosync 项目的领域。也许我们应该协调输入/输出，甚至在此阶段集成调用其一些库代码。作者指出，从 OFX 服务器获取数据非常容易，尽管需要处理和过滤开始/结束日期。

自动获取支持会因机构所在地而异。一些地方支持非常好，一些地方支持较少。使用 [<u>ofxhome.com</u>](http://ofxhome.com) 的数据进行配置。

#### 获取价格<a id="fetching-prices"></a>

对于获取价格，有许多库可以使用。最初我们将 Beancount 的 bean-prices 移植到 ledgerhub。

### 识别<a id="identification"></a>

识别阶段包括运行一个驱动程序

- 在目录层次结构中搜索文件（通常是您的 ~/Downloads 文件夹）

- 如果需要，将文件转换为某种文本/ASCII 格式，以便可以对其进行正则表达式匹配（即使输出是混乱的，例如将 PDF 文件转换为 ASCII）。这对 PDF 文件效果很好：尽管我们通常无法从中提取交易数据，但我们通常可以可靠地识别它们所属的账户，并且几乎总是能够提取对账单日期。

- 检查一系列正则表达式是否与 ASCII 化内容匹配。如果所有正则表达式都匹配，则配置与文件名关联。

注意，可能会有多个配置与同一个文件关联，因为一些文件包含多个部分，不同的导入器可能会被调用以提取它们的数据（例如，OFX 银行和 OFX 信用卡可能混在同一个文件中，有些机构会这样做）。

此过程的最终结果是每个文件名与配置文件中实例化的特定导入器对象的关联。这些导入器对象是用生成 Ledger 类似语法所需的一组账户名称创建的，以处理与其关联的下载文件。以下是两个导入器的示例配置：

```python
from ledgerhub.sources.rbc import rbcinvesting, rbcpdf

CONFIG = [

(('FileType: application/vnd.ms-excel', r'Filename: .*Activity-123456789-', ),  
rbcinvesting.Importer({  
'FILE' : 'Assets:CA:RBC-Investing:Taxable',  
'cash' : 'Assets:CA:RBC-Investing:Taxable:Cash',  
'positions' : 'Assets:CA:RBC-Investing:Taxable',  
'interest' : 'Income:CA:RBC-Investing:Taxable:Interest',  
'dividend' : 'Income:CA:RBC-Investing:Taxable:Dividends',  
'fees' : 'Expenses:Financial:Fees',  
'commission' : 'Expenses:Financial:Commissions',  
'transfer' : 'Assets:CA:RBC:Checking',  
})),  
  
(('FileType: application/pdf',  
'Filename:.*/123456789-\d\d\d\d[A-Z][a-z][a-z]\d\d-\d\d\d\d[A-Z][a-z][a-z]\d\d.pdf'),  
rbcpdf.Importer({  
'FILE': 'Assets:CA:RBC-Investing:RRSP',  
})),

]
```

配置包括每个可能导入器的一个列表，其中包含一对 1）与“匹配文本”（文件内容的“文本化”版本）匹配的一系列正则表达式，如果所有正则表达式都匹配，则与一个导入器对象关联，并 2）一个导入器对象，用于生成交易所需的特定账户名称。每个导入器需要一组特定的输出账户，用于创建其交易和分录。账簿的文件名和这些（正则表达式，导入器）对的列表是驱动程序执行其所有工作的必要条件。

文本化是指将下载文件转换为某种格式的简单和不完美的转换，以便我们可以对其运行正则表达式。对于 OFX 文件或 CSV 文件，不需要进行文本化转换，可以直接匹配这些文件的文本内容；对于 Excel/XLS 文件，需要将其转换为 CSV 文件，然后可以进行搜索；对于 PDF 文件，需要尝试多个 pdf-to-text 转换器，直到一个成功（这些工具非常不可靠，因此我们需要尝试各种工具）。注意，这种转换的“匹配文本”只是临时创建的，仅用于识别；导入器将获得原始二进制文件来完成其工作。

尚不完全清楚是否可以标准化正则表达式以避免用户手动配置它们。在实践中，我发现配置每个可能的下载确实需要用户在查看每个文件内容时进行一些猜测，这比试图规范化此过程更可靠，可能因为这是区分特定用户的所有文件而不是区分所有类型文件的更容易的问题。使用账户 ID 作为正则表达式之一是一种简单的方法，它效果很好。这也为将账户列表附加到特定导入器提供了一个清晰的位置，这本身需要用户输入。

### 提取<a id="extraction"></a>

关联完成后，我们在每个文件上运行导入器。生成某种数据结构。每个导入器都做它们自己的事情——这就是丑陋的技巧所在。理想情况下，我们应该构建一个常用工具库，以帮助解析类似文件类型。

尽管每个导入器模块应该相对独立，但可以设想一些常见功能，例如如何处理单个投资账户中的不同股票，可以在每个导入器之外配置（例如，首选方法可以是为该账户创建一个子账户，使用股票的符号，或其他方式）。

注意 [AMaffei]：如果您想要选择将各个步骤作为独立的 UNIX 风格工具运行，并/或使用常规文本处理工具处理中间文件，可以输出一个通用且定义良好的 CSV 文件格式。

### 转换<a id="transform"></a>

一些转换应该独立于导入器。特别是，自动分类不完整的交易与创建交易的导入器无关。我希望此步骤尽可能通用，以便在将来可以插入其他修饰步骤。现在，我只能想到以下用途：

1. 自动分类只有单边的交易

2. 检测重复交易：导入的文件通常包含已经在账簿中的交易；这些应该被忽略或标记为已存在。在实践中，这并不像听起来那么简单，因为直接比较日期+叙述会失败：如果同一交易来自两个输入数据文件，一侧总是会合并到另一侧，有时日期甚至会略有不同。需要进行一定程度的模糊匹配。

3. 规范化收款人名称：导入的收款人名称通常会被截短或包含一些无关的词，例如“LLC”、城市名称和/或编号。可能希望以某种方式自动清理这些名称。

此步骤涉及一个引导阶段，我们将从实际导入交易的账簿中提取一些数据。我们将实现一个通用接口，允许每个账簿语言实现提供训练所需的相关数据。

此处的输出数据应与其输入相同，以便我们可以选择性地跳过此阶段。

### 呈现<a id="rendering"></a>

驱动程序应选择一个输出呈现器。在这里，我们将提取的数据结构转换为您使用的特定账簿实现的语法。每个呈现器实现应该可以自由导入其特定实现的模块，我们应该小心地将这些导入依赖限制在这些模块中，以确保代码运行只需要一个账簿实现。

此处可以定义每个呈现器的呈现样式选项，因为每种语言都有其特殊性。

\[AMaffei\] 此外，应该可以提供一个通用呈现器，使用 printf 风格的格式字符串以任何所需格式输出。

### 归档<a id="filing"></a>

导入器应能够查看文件的文本化内容并找到文件/对账单日期。这非常有用，因为我们可以通过在文件名前添加对账单日期来重命名文件，而下载对账单或交易文件的日期通常与生成文件的日期不同。如果我们无法从文件中提取日期，则会回退到文件名的最后修改时间。

应提供目标目录，我们应将每个文件移动到与其关联的账户。例如，一个这样的文件：

```plaintext
~/Downloads/ofx32755.qbo
```

应移动到目录

```plaintext
.../Assets/US/RBC/Checking/2013-11-27.ofx32755.qbo
```

如果识别步骤将其与 Assets:US:RBC:Checking 账户的导入器关联。为此，所有导入器应具有与其关联的必需“归档”账户。

据我所知，目前只有 Beancount 实现了这一点，但我怀疑这种组织和保存导入文件的方便机制会被其他人发现是有用的。给定一个目录列表，Beancount 会自动找到这些文件，并使用文件名中的日期，能够在日记账网页中呈现文件的链接，并在用户点击链接时提供其内容。即使没有这种功能，也可以用来维护文档的缓存（我将我的缓存保存在一个仓库中，并同步到外部驱动器进行备份）。

## 实现细节<a id="implementation-details"></a>

关于初始实现的注意事项：

- 此项目的实现将使用 Python3 进行。为什么选择 Python？

  - 导入和提取的性能基本无关紧要，动态语言非常适合这类任务

  - 使用动态语言解析效果很好，有很多可用的库

  - Python3 现在广泛分发，所有所需的解析库都普遍可用

- 所有模块都应进行测试，包括使用示例输入进行测试。如果您想添加一个新模块，则需要为其提供一个匿名示例文件。我们将必须有一个自动化测试套件，因为过去的经验表明这类代码对新的和意想不到的输入非常脆弱且容易破裂。代码容易编写，但也容易破裂。

  - 为了测试无法匿名化的二进制文件，我们将提供从匹配文本而不是原始二进制对账单 PDF 进行测试的能力。这些文件通常无法提取，主要用于识别和归档（例如 PDF 对账单，我们无法从中提取任何有意义的数据，可能只能提取对账单日期）。

- 应该有一种快速测试特定下载文件的特定导入器的方法，零配置，即使输出账户名称有点混乱。

- 需要有干净且可读的跟踪导入器正在做什么，包括调试/详细选项。

- 提供一个函数，作为您自己的导入脚本的驱动程序。您的配置是一个脚本/您的脚本是配置。您在末尾调用一个函数。我们还将提供一个脚本，导入一个文件名并从中获取一个属性，对于那些想要更传统调用方式的人。

- 应该保持类型简单，但使用标准的日期时间类型表示日期，使用 decimal.Decimal 表示数字，使用字符串表示货币/商品。

这显然基于我目前在 Beancount 中的导入器代码。我非常开放新想法和建议。欢迎合作。我们支持的导入器越多越好。

## 导入器接口<a id="importers-interface"></a>

每个导入器应该实现一个从这个类派生的类：

```python
class ImporterBase:
    """所有源导入器的基类/接口。"""

    # 所需配置变量及其文档字符串的字典。
    # 这声明了导入器所需提供的选项列表及其含义。
    REQUIRED_CONFIG = {}

    def __init__(self, config):
        """创建一个导入器。
        大多数具体实现可以直接使用这个构造函数而无需重写。

        参数：
        config：配置账户的字典，必须匹配 REQUIRED_CONFIG 的值。
        """
        # 配置值的字典。可以公开访问。
        assert isinstance(config, dict)
        self.config = config

        # 检查配置是否仅具有所需的配置值。
        if not verify_config(self, config, self.REQUIRED_CONFIG):
            raise ValueError("Invalid config {}, requires {}".format(
                config, self.REQUIRED_CONFIG))

    def get_filing_account(self):
        """返回用于移动输入文件的账户。

        返回：
        与此导入器对应的账户名称。
        """
        return self.config['FILE']

    def import_file(self, filename):
        """尝试导入文件。

        参数：
        filename：要导入的文件名。
        返回：
        从文件中提取的新导入条目列表。
        """
        raise NotImplementedError

    def import_date(self, filename, text_contents):
        """尝试获取与给定文件对应的日期。

        参数：
        filename：要从中提取日期的文件名
        text_contents：文件内容的 ASCII 文本版本，
        不论其原始格式为何。
        返回：
        日期对象（如果成功）或 None。
        """
        raise NotImplementedError
```

对于每个导入器，应该提供如何找到和下载机构网站上的原始输入文件的详细说明，以帮助用户在添加此导入器时找到正确的下载文件（一些机构提供各种下载格式）。此外，应该提供输入文件支持的一行描述，以便我们可以在运行时呈现支持文件类型的列表。

## 参考文献<a id="references"></a>

其他旨在将账户数据导入 Ledger 的项目在此列出。

- [<u>Ledger 的“convert”命令</u>](http://ledger-cli.org/3.0/doc/ledger3.html#The-convert-command)

- HLedger 及其 [<u>内置</u>](http://hledger.org/manual#csv-files) [<u>读取器</u>](http://hledger.org/manual#timelog-files)

- <u>Reckon</u>

- [<u>OFXmate</u>](https://github.com/captin411/ofxmate)（GUI for ledger-autosync）

- [<u>CSV2Ledger</u>](https://github.com/jwiegley/CSV2Ledger)

- [<u>icsv2ledger</u>](https://github.com/quentinsf/icsv2ledger)

- [<u>csv2ledger</u>](http://www.khjk.org/log/2009/oct/csv2ledger.hs)（似乎缺乏活跃的维护者）

更新（2015年11月）：此设计文档已实现，项目正在重新整合到 Beancount 中。详情请阅读[<u>此处</u>](https://docs.google.com/document/d/1Bln8Zo11Cvez2rdEgpnM-oBHC1B6uPC18Qm7ulobolM/)。
