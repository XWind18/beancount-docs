# Beancount 精度与容差<a id="title"></a>

[<u>Martin Blais</u>](http://plus.google.com/+MartinBlais)，2015年5月

[<u>http://furius.ca/beancount/doc/tolerances</u>](http://furius.ca/beancount/doc/tolerances)

*本文档描述了 Beancount 如何处理交易余额检查和余额断言中的数字精度限制。它还记录了自动推断数字时可能发生的舍入。*

## 动机<a id="motivation"></a>

Beancount 自动强制要求输入文件中的交易分录金额相加为零。为了让 Beancount 以现实的方式验证这一点，它必须容忍一定量的精度误差。这是因为 Beancount 让你**重现现实世界账户交易中发生的情况**，而在现实世界中，机构为了实用目的会将金额四舍五入。

以下是一个例子：考虑以下在不同货币（美元和欧元）账户之间转账的交易：

    2015-05-01 * "从秘密瑞士银行账户转账"
      Assets:CH:SBS:Checking   -9000.00 CHF
      Assets:US:BofA:Checking   9643.82 USD @ 0.93324 CHF

在这个例子中，使用的汇率是 0.93324 USD/CHF，即每美元 0.93324 瑞士法郎。银行给出的汇率精确到 5 位数。9000.00 CHF / 0.93324 CHF 的全精度转换结果为 **9643.82152501...** USD。同样，使用给定的汇率将美元转换为法郎也会产生不精确的结果：9643.82 x 0.93324 = **8999.9985768…** 。

这是另一个可能发生这种舍入的例子：一笔购买某基金份额的交易：

    2013-04-03 * "购买基金 - 基于收盘价的价格"
      Assets:US:Vanguard:RGAGX       10.22626 RGAGX {37.61 USD}
      Assets:US:Vanguard:Cash         -384.61 USD

在这个交易中，再次发生了舍入：不仅基金的净资产值被四舍五入到最接近的便士值（$37.61），而且份额数也被四舍五入，并由 Vanguard 以固定位数记账（10.22626 单位 VPMBX）。整个交易的余额需要容忍一些误差，无论你计算份额的价值（10.22626 x $37.61 = **$384.6096386**）还是根据所需的美元金额计算份额数（$384.61 / $37.61 = **10.2262696091**）。

从 Beancount 的角度来看，上述两个例子都是平衡交易。显然，如果我们要在输入文件中表示和重现外部账户的交易，就需要在余额验证算法中有一定的容差。

## 如何确定精度<a id="how-precision-is-determined"></a>

Beancount 尝试为每个交易**自动**推断每个交易的精度**，**并且是**单独**从输入推断出来的[^1]。让我们再次检查我们的最后一个例子：

    2013-04-03 * "购买基金 - 基于收盘价的价格"
      Assets:US:Vanguard:RGAGX       10.22626 RGAGX {37.61 USD}
      Assets:US:Vanguard:Cash         -384.61 USD

在这个交易中，Beancount 将推断出以下精度：

-   RGAGX 的小数点后 5 位，即 **0.000005 RGAGX**，和

-   USD 的小数点后 2 位，即 **0.005 USD**。

请注意，使用的容差是用户提供的最后一位精度的**一半**。这完全是从输入中推断出来的，而无需获取任何全局容差声明。还要注意，精度是**分别为每种货币**计算的。

虽然我们正在为 RGAGX 的单位推断容差，但实际上它在这个交易的平衡中并没有使用，因为第一个分录的“权重”是以 USD 表示的（10.22626 x 37.61 = 384.6096386 USD）。

那么这里发生了什么？计算每个分录的权重：

-   第一个分录的权重为 384.6096386 USD

-   第二个分录的权重为 -384.61 USD

这些权重按货币相加（此交易的权重中只有 USD），导致**剩余**值为 -0.0003614 USD。这个值与 USD 单位的容差进行比较：|-0.0003614| < 0.005，这个交易是平衡的。

### 价格和成本<a id="prices-and-costs"></a>

为了推断使用的容差，**忽略**了在交易分录上声明的价格和成本金额。如果考虑到这些通常比分录的基本金额更高精度，这就说得通了——有时这种额外的精度是使交易平衡所必需的。这些不应该用于设置整个交易的精度。

例如，在以下交易中：

    1999-09-30 * "归属 ESPP - 按折扣价购买：18.5980 USD"
         Assets:US:Schwab:ESPP            54 HOOL {21.8800 USD}
         Income:CA:ESPP:PayContrib  -1467.84 CAD @ 0.6842 USD
         Income:CA:ESPP:Discount     -259.03 CAD @ 0.6842 USD

这里唯一推断出的容差是 CAD 的 0.005。（在这种情况下，54 HOOL 不产生任何影响，因为它是整数；下一节解释了这一点）。USD 没有推断出容差，无论是第一个分录的成本（21.8800 USD），还是其余分录的价格（0.6842 USD）。

### 整数金额<a id="integer-amounts"></a>

对于输入中的整数金额，精度**不**推断为 0.5，也就是说，这应该无法平衡：

    2013-04-03 * "购买基金 - 基于收盘价的价格"
      Assets:US:Vanguard:RGAGX    10.21005 RGAGX {37.61 USD}
      Assets:US:Vanguard:Cash         -384 USD

换句话说，整数金额不为其货币的精度确定贡献位数。

默认情况下，没有推断出精度的金额使用的容差为**零**。因此，在这个例子中，由于我们无法推断出 USD 的精度（回想一下，成本被忽略），这个交易将无法平衡，因为其剩余值非零（|-0.0003614| > 0）。

您可以自定义每种货币的默认容差，并且可以为任何货币设置默认容差（参见下文了解如何设置）。

这种整数金额的处理方式意味着仅通过输入数字可以指定的**最大精度**为货币单位的 0.05，例如，通过输入数字 10.7[^2]。另一方面，默认容差的设置允许指定任意数字。

### 解决歧义<a id="resolving-ambiguities"></a>

一种罕见的情况是对同一货币输入多个不同精度的情况。在这种情况下，使用推断出的输入容差中的**最大**（最粗略）的容差。

例如，如果我们希望将收入精确到便士以上，可以这样写：

    1999-08-20 * "出售"
      Assets:US:BRS:ESPP           -81 HOOL {26.3125 USD}
      Assets:US:BRS:Cash       2141.36 USD
      Expenses:Financial:Fees     0.08 USD
      Income:CA:ESPP:PnL       -10.125 USD

在这种情况下，我们的 USD 金额为 2141.36、0.08 和 -10.125，这些推断出 0.005 或 0.0005 的容差。我们选择最粗的金额：这个交易容忍 0.005 USD 的不精确度。

### 默认容差<a id="default-tolerances"></a>

当交易的数字不能提供足够的信息以**局部**推断出容差时，我们会退回到某个默认容差值。如前例所示，这可能发生在（a）与我们需要的货币相关的金额为整数，或（b）输入中根本没有足够的数字。

默认情况下，这个默认容差对所有货币为**零**。可以使用选项指定，如下所示：

    option "inferred_tolerance_default" "*:0.001"

可以通过提供货币来进一步细化每种货币的默认容差，如下所示：

    option "inferred_tolerance_default" "USD:0.003"

如果提供了货币特定的容差，将优先于全局值使用。

这个选项的一般形式是：

    option "inferred_tolerance_default" "<currency>:<tolerance>"

为了清楚起见：这个选项*仅*在无法推断出容差时使用。如果您有过大的舍入误差并且交易中的数字推断出一些容差值，这个值将被忽略（例如，将其设置为更大的数字来尝试解决这个问题是无效的）。如果需要放宽容差，请参阅下一节中的“`inferred_tolerance_multiplier`”。

*(注意：我一直在考虑为商品指令指定一个专用的元数据字段，但这会打破元数据仅供用户和插件使用的不变性，因此我迄今为止还没有这么做。)*

### 容差乘数<a id="tolerance-multiplier"></a>

我们之前展示过，当容差值没有明确提供时，它是从分录上的数字推断出来的。默认情况下，找到的最小数字除以一半以获得容差，因为我们假设我们正在重现交易的机构应用了舍入，因此误差永远不应超过一半。

但实际上，您可能会发现舍入误差有时超过这个值。为此，我们提供了一个选项来设置推断容差的乘数：

    option "inferred_tolerance_multiplier" "1.2"

这个值覆盖默认乘数。在这个例子中，对于一个只有 24.45 CHF 数值的交易，CHF 的推断容差将是 +/- 0.012 CHF。

### 从成本推断容差<a id="inferring-tolerances-from-cost"></a>

还有一个功能是扩展推断出的最大容差，包括通过成本或价格持有的分录推断出的成本货币值。这些分录可以通过将单位的最小数字乘以成本或价格值并取该值的一半来暗示容差值。

例如，如果一个分录附有金额“2.345 RGAGX {45.00 USD}”，它暗示的容差是 0.001 x 45.00 / 2 = 0.045 USD，并计算所有以成本持有或从价格转换的分录的舍入误差的总和，结果的容差将添加到用于确定给定商品的容差的候选列表中（我们使用所有推断容差的最大值）。

可以这样启用此功能：

    option "infer_tolerance_from_cost" "TRUE"

启用此标志只会使容差潜在地更宽，而不会更小。

## 余额断言和填充<a id="balance-assertions-padding"></a>

在其他一些地方也需要近似比较。余额断言还会比较两个数字：

    2015-05-08 balance Assets:Investments:RGAGX       4.271 RGAGX 

这断言此账户的累计余额为 4.271 单位 RGAGX，正负 0.001 RGAGX。因此，4.270 RGAGX 至 4.272 RGAGX 的累计值将如预期。

容差自动推断为余额断言数字的最小有效数字的 1 个单位。如果需要更宽松的断言，可以声明：

    2015-05-08 balance Assets:Investments:RGAGX       4.27 RGAGX 

这个断言将接受 4.26 RGAGX 到 4.28 RGAGX 的值。

请注意，推断出的容差也会因上面讨论的推断容差乘数而扩大。

### 触发填充的容差<a id="tolerances-that-trigger-padding"></a>

填充指令自动插入交易以使账户余额与随后的余额断言一致。仅当余额与预期值不一致时才会触发插入，触发此操作的容差行为与余额断言完全相同。

### 余额断言上的显式容差<a id="explicit-tolerances-on-balance-assertions"></a>

Beancount 支持指定显式容差金额，如下所示：

    2015-05-08 balance Assets:Investments:RGAGX       4.271 ~ 0.01 RGAGX 

添加这个功能是因为观察到 Vanguard 投资账户的一些特殊情况，舍入似乎遵循奇怪的规则，余额不匹配。

## 保存舍入误差<a id="saving-rounding-error"></a>

如前所述，交易不必完全平衡，它们允许一定量的误差。这让一些人感到困扰。如果你想跟踪和衡量容差允许的剩余金额，Beancount 提供了一个选项，可以自动插入分录使每个交易完全平衡。

可以这样启用此功能：

    option "account_rounding" "Equity:RoundingError"

这告诉 Beancount 插入分录以补偿舍入误差到“`Equity:RoundingError`”账户。例如，启用此功能后，以下交易：

    2013-02-23 * "购买某物"
      Assets:Invest     1.245 RGAGX {43.23 USD}
      Assets:Cash      -53.82 USD                                         

将自动转换为：

    2013-02-23 * "购买某物"
      Assets:Invest             1.245 RGAGX {43.23 USD}
      Assets:Cash              -53.82 USD
      Equity:RoundingError   -0.00135 USD                                         

可以验证这个交易完全平衡。如果交易已经完全平衡（这是大多数交易的情况），则不会插入任何分录。

最后，如果要求所有账户都明确打开，请记住在适当的日期在文件中声明舍入账户，如下所示：

    2000-01-01 open Equity:RoundingError

## 推断数字的精度<a id="precision-of-inferred-numbers"></a>

Beancount 能够推断输入中缺失的一些数字。例如，Beancount 会自动插入此交易的第二个分录：

    2014-05-06 * "购买基金"
      Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
      Assets:Investments:Cash

从第一个分录计算出的插入金额为 -227.2067 USD。现在，您可能会问，以什么精度插入？它是以全精度插入 227.2067 USD 还是四舍五入到便士，例如 227.21 USD？

这取决于推断出的货币容差。在这个例子中，无法推断出任何容差（除了成本金额外没有提供其他 USD 金额，成本金额在推断容差时被忽略），所以我们必须依赖默认容差。

如果默认容差没有在输入文件中覆盖——因此为零——将使用全精度；不进行舍入。这将导致以下交易：

    2014-05-06 * "购买基金"
      Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
      Assets:Investments:Cash    -227.2067 USD

请注意，如果可以从该交易的其他数字推断出容差，将用于舍入，例如在此示例中，由于佣金分录上的 9.95 USD 数值，现金分录四舍五入到两位数：

    2014-05-06 * "购买基金"
      Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
      Expenses:Commissions            9.95 USD
      Assets:Investments:Cash      -237.16 USD

然而，如果无法进行推断，并且 USD 的默认容差设置为 0.001，则数字将在插入前量化为 0.001，即 227.207 USD 将被存储：

    option "default_tolerance" "USD:0.001"

    2014-05-06 * "购买基金"
      Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
      Assets:Investments:Cash     -227.207 USD

最后，如果启用了舍入误差的积累，分录的金额将反映正确的剩余值，考虑到自动插入的四舍五入金额：

    option "default_tolerance" "USD:0.01"
    option "account_rounding" "Equity:RoundingError"

    2014-05-06 * "购买基金"
      Assets:Investments:RGXGX        4.27 RGAGX {53.21 USD}
      Assets:Investments:Cash     -227.207 USD
      Equity:RoundingError          0.0003 USD

## 迁移现有输入<a id="porting-existing-input"></a>

从交易数字推断容差值通常足以使现有文件无需更改即可工作。处理这些文件时可能会出现新的错误，但它们要么指向输入中以前未检测到的错误，要么可以通过简单添加适当数量的数字来修复。

作为证明，作者非常大的输入文件的迁移过程相对轻松，耗时不到 1 小时。

为了简化过渡，您可能希望更改所有货币的默认容差以匹配 Beancount 之前使用的值，如下所示：

    option "inferred_tolerance_default" "*:0.005"

我建议您从此开始并修复文件中的所有错误，然后继续删除此选项并修复其余错误。这应该使您的文件适应这种新行为变得更容易。

作为修复新错误的示例… 从整数金额部分将这个新失败的交易转换为：

    2013-04-03 * "购买基金 - 基于收盘价的价格"
      Assets:US:Vanguard:RGAGX    10.21005 RGAGX {37.61 USD}
      Assets:US:Vanguard:Cash         -384 USD

通过插入零以提供本地推断值，如下所示：

    2013-04-03 * "购买基金 - 基于收盘价的价格"
      Assets:US:Vanguard:RGAGX    10.21005 RGAGX {37.61 USD}
      Assets:US:Vanguard:Cash      -384.00 USD

足以消除余额检查。

## 表示问题<a id="representational-issues"></a>

在内部，Beancount 使用十进制数表示法（不是二进制/浮点表示法，也不是有理数）。导致大量小数位的计算会进行到 28 位小数（Python IEEE 十进制实现的默认精度）。这已经足够了，因为上述方法很少会将这些类型的数字传递到系统的各个部分：容差允许我们发布用户声明的精确金额，只有自动派生的价格和成本才可能导致计算到不现实的小数位数的精度，这些精度可能会渗透到系统的其他部分。

## 参考文献<a id="references"></a>

可以在[<u>此处</u>](rounding_precision_in_beancount.md)找到导致此实现的[<u>原始提案</u>](rounding_precision_in_beancount.md)。特别是，该提案突出了其他系统如何尝试解决这个问题的内容。邮件列表中也有[<u>一些讨论</u>](https://groups.google.com/forum/#!msg/ledger-cli/m-TgILbfrwA/YjkmOM3LHXIJ)专门讨论这个主题。

请注意，很长一段时间以来，Beancount 在所有货币中的固定精度为 0.005。一旦实现了本文档中描述的方法，这就被消除了。

此外，对于 Balance 和 Pad 指令，曾经有一个“tolerance”选项，默认设置为任何单位的 0.015。随着本文档中描述的更改的合并，此选项已被弃用。

## 历史记录<a id="historical-notes"></a>

以下是截至 2016 年 3 月 Beancount 数字呈现状态的概述，[<u>来自邮件列表</u>](https://groups.google.com/d/msg/beancount/frfN1zc6TEc/d5OjuDnREgAJ)：

> 首先，重要的是要了解这些数字在内存中的表示方式。它们使用十进制表示法，不仅能够准确地表示十进制数字（与二进制浮点提供的近似值相对），还包含特定的精度。也就是说，数字 2.00 与数字 2.0 和 2.000 表示不同。数字“记住”了它们的表示精度。这很重要。当我说渲染数字到其“自然精度”时，我的意思是它们的表示精度，即 2.0 渲染为“2.0”，2.000 渲染为“2.000”。
>
> 然后，有两个截然不同的主题：（1）容差，（2）精度。

-   “容差”是用于确定在平衡交易中可接受的误差值。这在验证阶段使用，用于确定允许的松散程度。它不应影响数字的渲染方式。

-   “精度”可能有点误称：我所指的是数字应渲染的小数位数。

> 曾几何时——在 shell 已经编写之后——这些概念在 Beancount 中并没有被很好地定义，我没有一致地处理这些事情。某个时刻，变得清楚我需要做什么，我创建了一个名为“DisplayContext”的类，可以包含每种货币渲染数字精度的适当设置（每种货币都有其最常见的渲染精度，例如 USD 为两位，MXN 为一位，JPY 为无位数，在报告中我们通常可以将实际数字四舍五入到该精度）。因此，这个 DisplayContext 实例在解析器中自动实例化，为了避免用户手动设置这些值——Beancount 默认会“做正确的事”——[<u>它能够累积</u>](https://github.com/beancount/beancount/blob/master/beancount/core/display_context.py) 看到的数字，并推断出使用的最常见和最大位数作为默认渲染数字的位数。最常见的格式/位数用于渲染单位数，看到的最大位数用于渲染成本和价格。此外，这个类还具有对齐小数点和在千位插入逗号的功能。它将格式控制与数字本身分开。
>
> 渲染数字的大部分代码使用 DisplayContext（通过 to\_string() 方法）将数字转换为字符串，例如 Web 界面和显式文本报告。但并非全部……这里有一点历史……SQL shell 使用了一些[<u>旧的特殊用途代码</u>](https://github.com/beancount/beancount/blob/master/beancount/query/query_render.py)来渲染数字，我从未费心将其转换为 DisplayContext 类。有一个[<u>待办事项</u>](https://github.com/beancount/beancount/blob/master/TODO)，需要在某个时候进行转换，但我到目前为止忽略了这个，因为我对 SQL 查询引擎有更大的计划，涉及对其进行全面重写，包含许多改进，我想我会在那时进行。如果你记得，SQL 查询引擎是一个原型，实际上它确实有效，但没有被单元测试很好地覆盖。我的目的是通过使用发现什么是有用的，然后编写一个更好的 v2。
>
> 现在，关于 PRINT 命令……这不是一个报告工具。打印机的目的是打印准确代表交易内容的输入。为此，它需要以“自然”精度渲染数字，以便在读取回时，它们解析为相同的数字，即相同的位数（即使是零）。因此，PRINT 命令不会尝试使用从输入文件派生的 DisplayContext 实例进行渲染——这是有意的。我可以更改它，但那样的话，回路会中断：使用 DisplayContext 格式化结果的舍入可能会输出不再平衡的交易。
>
> 正如你所见，这不是一个显而易见的话题……希望这可以帮助你了解 Beancount 在渲染数字精度方面的输出。
>
> 注意：“default\_tolerances”最近已重命名为“inferred\_tolerance\_default”，因为名称过于笼统且令人困惑。旧名称仍然有效但会生成警告。
>
> 我刚刚从你的评论和一些 grep 中注意到“render\_commas”选项不再使用。不知道这是怎么发生的，但我会立即去修复它并设置从输入派生的 DisplayContext 的默认值。
>
> 我可能还应该将 SQL shell 渲染转换为使用显示上下文，无论未来计划如何，这样它的渲染与所有其他内容一致。不确定这个周末是否能做到，但我会记录一个票据，[<u>这里</u>](https://github.com/beancount/beancount/issues/105)。
>
> 希望这有帮助。如果以上内容不清楚，欢迎提问。抱歉，如果这不是完全显而易见的……那里有不少历史记录和很多代码。我应该检查选项的命名，我认为所有的容差选项都有“tolerance”在其名称中，但没有覆盖渲染的选项，当我添加它们时，它们应该也有一个共同的名称。

## 延伸阅读<a id="further-reading"></a>

[<u>每个计算机科学家都应该知道的有关浮点算术的内容</u>](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#689)

[^1]: 这与 Ledger 的做法形成对比，后者试图根据文件中最近解析的其他交易推断精度，按文件顺序进行。这不幸地导致了交易之间在使用精度上的“交叉影响”。

[^2]: 请注意，由于 Beancount 在内部表示数字的方式，它也无法区分“230”和“230.”；它们在 Beancount 中解析为相同的表示。因此，我们无法在输入中使用这种区分来支持 0.5 的精度。
