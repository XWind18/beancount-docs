# Beancount 和 Ledger 的比较<a id="title"></a>

[<u>Martin Blais</u>](http://plus.google.com/+MartinBlais)，2014 年 9 月

[<u>http://furius.ca/beancount/doc/comparison</u>](http://furius.ca/beancount/doc/comparison)

*关于 Beancount 和 Ledger & HLedger 之间的差异，已经在邮件列表和私人邮件中多次提出。本文档重点介绍了这些系统之间的主要区别，因为它们在设计和实现上存在显著差异。*

*请记住，本文档是从 Beancount 的角度编写的，作为其作者，反映了我对 CLI 会计系统设计的偏见。我的目的是不打击其他系统，而是突出重要差异，以帮助新人了解这些系统在操作和功能上的不同，并可能与其他开发者展开富有成效的讨论。*

## 哲学差异<a id="philosophical-differences"></a>

（见[<u>这个讨论</u>](https://groups.google.com/d/msg/ledger-cli/B9qDXoSIJxQ/LVdzPkT6DAAJ)。）

首先，Ledger 是乐观的。它假设用户很容易输入正确的数据。根据我的经验，处理我们正在进行的数据输入是不可能正确完成的，没有许多自动检查。例如，未断言账户上的符号错误非常常见。相比之下，Beancount 是非常悲观的。它假设用户不可靠。它对输入施加了许多限制。例如，如果您在一个空账户中添加了一股 100 美元的 AAPL 股票，它不会允许您从中删除一股 101 美元的 AAPL 股票；您根本没有一股。它不假设用户能够或应该依赖于正确的顺序输入交易（使用日期断言而不是文件顺序断言）。它可选地检查收益是否与销售价格匹配（sellgains 插件）。它允许您在账户图表上施加额外的限制，例如，一个插件拒绝过账到非叶子账户，或者一个账户中拒绝多个商品，或者需要您声明所有账户的 Open 指令；根据您的需要选择不同的严格程度。它添加了比双重记账方法提供的更多的自动交叉检查。毕竟，交叉检查是我们选择使用双重记账方法的原因之一，为什么不对正确性检查更加严格呢？Beancount 应该吸引那些对自己不太信任的人。正因为如此，它不支持不平衡/虚拟过账；这不是一个缺点，这是有意为之的。

其次，设计理念不同。如用户手册中所示，Ledger 提供了各种各样的选项。这对许多人来说肯定很有吸引力，但对我来说，它似乎已经发展成一个非常复杂的单片工具。这些选项之间的相互作用以及许多选项的语义结果令人困惑且非常微妙。Beancount 提供了一种极简主义的方法：虽然有一些[<u>少量选项</u>](http://github.com/beancount/beancount/tree/v2/beancount/parser/options.py)，但它尽力避免这些选项。而那些确实影响交易语义的选项总是出现在输入文件中（命令行中没有任何选项），并且与特定工具的选项不同。加载文件总是会产生相同的交易流，无论将要使用哪个报告工具。唯一的命令行选项是那些影响报告工具特定行为的选项；这些选项不会改变交易流的语义。

第三，Beancount 在流处理方面有更深的拥抱。它的加载器创建了一份有序的指令列表，所有指令共享一些共同属性（名称、日期、元数据）。这些是所有数据。Ledger 中被视为“语法”的指令在 Beancount 中被定义为普通指令对象，例如“Open”在 Beancount 中没有特殊意义，并且自身没有任何作用。它仅在一些应用约束的例程中使用（是否见证到一个账户的 Open 指令？）或可能想挂在其上的每个账户的元数据中使用。价格也被指定为指令并嵌入在流中，可以以这种方式生成。所有内部操作都定义为处理和输出指令流。这使得允许用户在处理管道中插入自己的代码来执行对指令流的任意转换成为可能——一切皆有可能，不受特定表达语言语义的限制。这是一种机制，允许用户通过编写简短的 Python 插件来构建新功能，这些插件在 Beancount 的核心运行，而不是在其数据边缘访问的 API。如果有必要，Beancount 自身的内部处理将朝着减少自身操作并将所有工作移交给这些插件的方向发展，甚至可能允许插件声明指令类型（除了交易对象）。它正在演变成一个浅层驱动程序，只是组装一个处理管道来生成指令流，配有方便的库和函数操作。

## 具体差异<a id="specific-differences"></a>

### 库存记账和成本基础处理<a id="inventory-booking-cost-basis-treatment"></a>

Beancount 应用严格的规则来减少其账户内容的库存。这意味着您只能从一个账户中取出之前（在时间上）放入的东西，否则会产生错误。这对于“按成本持有”的单位（例如，股票）来说是强制执行的，以确保

- 成本基础永远不会从账户中泄漏，

- 我们可以检测到交易数据输入中的错误（这些错误非常常见），以及

- 我们能够正确计算资本收益。

相比之下，Ledger 不对时间上的库存记账进行检查：所有批次都只是简单地累积，不考虑库存的先前内容（没有区分批次增加和减少）。在 Beancount 中，库存内容的减少需要与指定成本基础的特定批次匹配。

在 Ledger 中，输出对此有些误导：为了简化报告输出，用户可以指定几种类型的批次合并算法。默认情况下，打印所有批次的单位总和，但使用这些选项可以告诉报告生成考虑成本基础（它称之为“价格”）和/或批次创建的日期，在这种情况下，它将单独报告具有不同成本基础和/或日期的批次。您可以通过命令行选项选择哪种类型的合并发生，例如--lot-dates。最重要的是，这意味着在 Ledger 中，可以从账户中移除从未添加到该账户的批次。这导致长短批次的混合，不准确地表示账户中实际发生的变化。然而，它可以轻松实现平均成本基础报告。

我认为这不仅令人困惑，而且是对账户库存的[<u>不正确</u>](https://groups.google.com/d/msg/ledger-cli/zRSMle5AV3Q/gAK4EbwbgXsJ)处理，并且我已经争论这可能导致泄漏和不正确的计算。更多详细信息和示例[<u>在此处提供</u>](a_proposal_for_an_improvement_on_inventory_booking.md)。此外，[<u>直到最近</u>](https://groups.google.com/d/msg/ledger-cli/A4-_OL3vvGE/Qn_4Qd5z9msJ) Ledger 还没有使用成本基础来平衡过账，以正确计算资本收益。出于这个原因，我怀疑 Ledger 用户可能没有使用它来计算和比较其收益与经纪人报告的价值。

为了使 Beancount 有意义地检测此类错误并在减少批次时实施严格的匹配纪律，事实证明，唯一需要应用的约束是特定账户不能同时持有同一种商品的长头寸和短头寸。例如，所有它需要做的是强制执行，您不能在同一个库存中同时持有 1 单位 GOOG 和 -1 单位 GOOG 的批次（无论其获取成本如何）。任何特定单位集合的减少都被检测为“批次减少”，并搜索与减少过账规格匹配的批次，通常，搜索与过账指定的成本相同的批次。在实践中，强制执行这一约束并不令人担忧，因为没有任何情况下您会希望在同一个账户中同时持有长头寸和短头寸，但如果您需要这样做，您可以简单地使用单独的账户来持有您的长头寸和短头寸（无论如何，建议您使用子账户来跟踪您在任何一种商品中的头寸，这将非常自然）。

最后，Beancount 正在实施[<u>一个提案</u>](a_proposal_for_an_improvement_on_inventory_booking.md)，显著扩展其库存记账的范围：语法将允许批次减少的松散规格，使用户可以轻松编写没有歧义的过账，并且支持按加拿大和全球所有税收递延账户的平均成本记账。它还将提供一种新语法，同时指定每单位成本和总成本，这一功能将使正确跟踪[<u>无佣金资本收益</u>](trading_with_beancount.md)成为可能。

### 货币转换<a id="currency-conversions"></a>

Beancount 在简单货币转换和按成本持有的商品转换之间做出重要的语义区分。例如，将 20000 美元转换为 22000 加元是一种货币转换（例如，在银行之间），在将结果加元单位插入目标账户后，它们不会被视为“每个成本为 1.1 美元的加元”，它们只是简单地作为加元单位留在账户中，没有记录用于转换它们的汇率。这准确地模拟了现实世界的运作方式。另一方面，将 5000 美元转换为每单位成本为 500 美元的 10 个 GOOG 股票单位被视为与货币转换不同的操作：结果 GOOG 单位具有特定的成本基础，库存批次保留单位价格的记忆（以及日期），并应用严格规则来减少这些批次（我称之为“记账”），如前所述。这用于计算和报告资本收益，最重要的是，它检测到数据输入中的*大量*错误。

相比之下，Ledger [<u>不区分这两种类型的转换</u>](https://groups.google.com/d/msg/ledger-cli/zRSMle5AV3Q/kBCYjVEB-gsJ)。Ledger 将货币转换和按成本持有的商品转换同等对待。这没有引起太多头疼的原因是因为没有库存记账——无论它们发生在哪种转换率下，所有批次都在账户中累积，具有正负值——对于简单商品（例如货币，如美元），不考虑每单位成本的单位总数净值提供了正确的答案。提供账户库存批次的完整列表作为一个选项（见 Ledger 的“--lot-dates”），并不是默认的账户余额渲染方式。我怀疑很少有用户使用这个功能：如果您确实为实际账户渲染批次列表，过去发生了许多货币转换，您会看到大量无关的批次。我认为货币转换的成本基础最好省略。

HLedger [<u>不解析成本基础语法</u>](https://groups.google.com/d/msg/hledger/ZB8pzWJGFy8/RziOVQ2XQ-QJ)，因此不识别它。

### 输入隔离<a id="isolation-of-inputs"></a>

Beancount *只*从您提供的文本文件中读取其所有输入。这种隔离是有意为之的。没有链接到外部数据格式或在线服务，例如历史价格值的获取器。获取和转换外部数据足够复杂，我认为这应该是独立项目的领域。这些问题领域也很好地自然地分割开来：Beancount 提供一个隔离的核心，允许您摄取所有交易数据并从中得出各种汇总报告，其语法是连接到外部交易存储库或价格数据库的枢纽。它通过这种方式与外部数据源的丑陋细节隔离开来。

可下载文件中的事务信息外部格式太多，无法涵盖所有这些格式。大多数机构提供的数据文件格式各不相同：OFX、Quicken、XLS 或 CSV，查看其内容显而易见，编写这些文件输出代码的程序员对其格式的标准定义并不十分关注；这是一件相当丑陋的事情。这些文件几乎总是非常混乱，而且随着时间的推移，这些文件会不断演变。

获取历史或当前价格信息同样令人讨厌。虽然 Yahoo 和 Google Finance 能够为美国交易所的普通股票提供一些基本的价格数据，但当您需要获取外国交易所交易的工具或通常不在交易所交易的工具（如共同基金）的信息时，要么数据不可用，要么如果有，您需要找出他们决定映射到的股票代码，几乎没有标准。您必须手动分配代码。最后，完全可能的是，您想管理没有现有外部价格来源的工具，因此您的记账软件必须提供一种机制，允许您手动输入价格值（Beancount 和 Ledger 都提供这种方法）。同一声明机制用于缓存历史价格数据，因此 Beancount 不需要始终联网。

大多数用户会想编写自己的导入脚本，但也有一些库存在：[<u>beancount.ingest</u>](http://github.com/beancount/beancount/tree/v2/beancount/ingest) 库（在 Beancount 中）提供了一个框架，以自动化各种机构可下载文件的识别、提取交易和归档。有关详细信息，请参阅其[<u>设计文档</u>](http://furius.ca/ledgerhub/doc/design-doc)。

相比之下，Ledger 和 HLedger 支持[<u>从 CSV 文件转换交易的基本功能</u>](http://ledger-cli.org/3.0/doc/ledger3.html#Converting-from-other-formats)，以及[<u>自动获取当前价格</u>](http://ledger-cli.org/3.0/doc/ledger3.html#Commodity-reporting)，使用您需要提供的外部脚本（`getquote`）。如果您要跟踪所有账户，CSV 导入远不足以满足实际需要，因此需要扩展此功能。连接到外部脚本是正确的做法，但 Beancount 倾向于在这个问题上采取强硬立场，不提供任何会触发网络访问的代码，也不支持任何外部格式作为输入。在 Beancount 中，您应自行集成价格更新，也许使用自己的脚本，并可能通过包含文件引入数据。（但如果您不喜欢这种方式，您也可以编写自己的插件模块，以获取实时价格。）

### 语言语法<a id="language-syntax"></a>

Beancount 的语法比 Ledger 的更简单，而且限制更多。在其 2.0 版本中，Beancount 的语法被重新设计为可由语法生成器轻松指定。为了使标记化不产生歧义，标记进行了简化。例如，

- 货币必须完全用大写字母表示（允许数字和一些特殊字符，如“\_”或“-”）。不支持货币符号（如 $ 或 €）。（另一方面，在 Ledger 中包含数字的货币需要引用。）

- 账户名称不允许有空格（尽管可以使用破折号），并且必须至少有两个组件，以冒号分隔。

- 描述字符串必须加引号，例如：“AMEX PMNT”。不再支持自由文本作为字符串。

- 日期仅从 ISO8601 格式解析，即“YYYY-MM-DD”。

- 标签必须以“\#”开头，链接以“^”开头。

- 除标签栈外，所有上下文信息已被删除。例如，没有账户别名，也没有 Ledger 中的“应用”概念（见“应用根”和“应用标签”）。它需要更多的冗长输入——完整的账户名称——因此假设您在编辑器中设置了账户名称补全。

这些变化使输入语法看起来更像编程语言。这些限制可能会惹恼一些用户，但总体上它们使解析分类账内容的任务更简单，结果的简单性将铺平道路，使人们更容易用其他语言编写解析器。（解析缩进仍然存在一些细微差别，但在所有上下文中，通过构建自定义词法分析器应轻松解决。）

由于其更松散和更用户友好的语法，Ledger 使用自定义解析器。如果需要从其他语言解析其内容，最好的方法可能是创建其源代码的绑定，或使用它将分类账的内容导出为 XML 然后解析它（这效果很好）。我怀疑解析方法可能会在 Ledger 的下一个版本中进行审查，因为使用解析器生成器可以为实验提供解放。

### 顺序独立性<a id="order-independence"></a>

Beancount 保证输入文件中指令的顺序与其计算结果无关。您应该能够根据自己的需要组织输入文件并重新排序任何声明，而不必担心软件将如何进行计算。甚至声明账户的指令（“Open”）也不需要出现在这些账户在文件中使用之前。所有指令都会解析，然后在进行任何计算或验证之前基本上稳定排序。这也使得实现多个文件的包含变得简单（如果愿意，可以将文件连接在一起）。

相比之下，Ledger 在解析输入文件时处理其过账的金额。在实现方面，这的优点是只需要一次遍历即可检查所有断言和余额，而在 Beancount 中，需要对整个指令列表进行多次遍历（在 Beancount 中，这并没有造成太大问题，因为即使是现实中大量的交易对我们的计算机来说也相当适中；大多数 Beancount 的处理时间是由于解析和数值计算）。

Ledger 计算方法的一个不幸的副作用是用户必须小心文件中交易出现的顺序。当编辑非常大的输入文件时，这可能是危险且难以理解的差异[<u>特别在余额断言中可见</u>](https://groups.google.com/forum/#!topic/ledger-cli/vwkrPh74NFI)。Ledger 的余额断言附加在交易指令的过账上，并按文件顺序计算（我称之为“文件断言”）。Beancount 的余额断言是单独的指令，在声明日期的开始应用，而不考虑它们在文件中的位置（称之为“日期断言”）。我认为日期断言更有用，更不容易出错，因为它们不依赖于声明的顺序。另一方面，Ledger 风格的文件断言自然支持对日内余额进行检查，而无需在交易中指定时间，这是日期断言无法实现的。

因此，考虑在 Beancount 中实施文件断言（作为对其日期断言的补充）的[<u>提案</u>](balance_assertions_in_beancount.md)已经提出。这可能会作为一个插件进行。Ledger 不支持日期断言。

### 账户类型<a id="account-types"></a>

Beancount 账户必须具有五类之一的特定类型：资产、负债、收入、费用和权益。Ledger 账户没有这种约束，您可以定义任何根账户，并且没有要求识别账户属于哪一类。这反映了 Ledger 更自由的设计：其设计旨在成为更通用的“计算器”。系统中没有强制或使用账户类型。

根据我的经验，我还没有看到任何无法将我的账户分类为这些类别之一的情况。对于更奇特的商品，例如“允许向 IRA 贡献的美元”，需要一些想象力来理解哪个账户适合哪个类别，但这是有逻辑的：如果账户有我们关心的*绝对*价值，那么它是资产或负债账户；如果我们只关心*过渡*价值，或一段时间内积累的价值，那么它应该是收入或费用账户。如果符号为正，那么它应该是资产或费用账户；相反，如果符号为负，那么它应该是负债或收入账户。权益账户几乎从未显式使用，由 Beancount 自己定义和使用，将期初余额、未分配利润和净收入转移到特定报告期的资产负债表（您选择的任何时期）。这个原则使得确定账户类型变得容易。我有从 2008 年到 2014 年的数据，能够用这五类表示*所有*我想要的一切。此外，我不认为要求用户对其账户进行这种分类会有任何限制；这只是需要一些预见。

要求这些账户类型的原因是它允许我们基于其类型执行逻辑操作。我们可以隔离收入和费用账户，并得出损益表和一个净收入值。然后我们可以将未分配利润（报告期前的收入）和净收入（报告期内的收入）转移到权益账户，并绘制资产负债表。我们可以生成持有清单，自动排除收入和费用，计算净值、每个账户的价值等。此外，我们可以使用账户类型来识别流入账户组的外部流量，并以一种可以与目标分配的市场回报进行比较的方式计算这些账户的正确回报率（注意：尚未集成，但已原型化并规格化，它有效）。最重要的是，拥有账户类型是一个有用的属性，因此我们强制您为每个账户选择一个类型。

账户类型的缺失可能也是为什么 Ledger 不提供资产负债表或损益表报告，仅提供试算平衡表的原因。优点是一个显得更松散和更宽松的命名结构。但也请注意，要求类型本身不会导致两种系统之间的计算差异，您仍然可以在这些账户中累积任何类型的“豆子”，它并不因此而不通用。类型只是 Beancount 的报告利用的额外信息。

### 交易必须平衡<a id="transactions-must-balance"></a>

Beancount 的交易必须平衡，这没有妥协，没有其他办法。这样做的好处是，任何交易子集的余额金额总和始终精确为*零*（我检查过）。

Ledger 允许用户进行两种特殊类型的过账：

- [<u>虚拟过账</u>](http://ledger-cli.org/3.0/doc/ledger3.html#Virtual-postings)：这些是用括号括起来的过账，不在交易余额总和中考虑，可以在其中输入任何值而不会导致错误。

- [<u>平衡虚拟过账</u>](http://ledger-cli.org/3.0/doc/ledger3.html#Working-with-multiple-funds-and-accounts)：这些过账用方括号括起来。这些过账的约束较少：在方括号内的过账集合强制平衡自身。

第二种情况可以看作是等效于两个交易：一个交易包含常规过账集合，另一个交易仅包含平衡虚拟过账（这不会造成问题）。第一个情况是有问题的：在试图解决会计问题时，初学者经常会将其作为一种托辞，而不是用双重记账方法来建模他们的问题。显然，大多数 CLI 会计系统的使用者是计算机科学家，而不是会计专业人士，当我们学习如何创建我们的账户图表并填写我们的分类账时，我们会犯错误。通常情况下，真正不明显如何解决这些问题；这需要经验。

但事实是，在 8 年的使用中，我没有遇到过一个真正需要虚拟过账的情况。Beancount 的第一个版本曾经支持虚拟过账，但我已经逐渐移除所有这些过账。我总是能够提出更好的账户集合，或者使用一种虚拟货币来跟踪我需要跟踪的内容。这总是导致更好的解决方案，有时甚至是意想不到和优雅的副作用。

但这些系统必须易于使用，那么我们如何解决这个问题呢？邮件列表是一个很好的开始，提问的地方，人们分享如何解决类似问题的信息（首先没有那么多“会计问题”）。我也在记录我为解决自己的会计问题而提出的所有解决方案在[<u>Beancount 烹饪书</u>](command_line_accounting_cookbook.md)中，基本上是我到目前为止学到的一切；这正在进行中。我希望这个不断发展的文档成为一个有用的参考，指导他人提出适合双重记账框架的解决方案，并提供大量示例，作为其他人复制的模板，以适应他们自己的数据。

如 Ledger 的作者所言：

“如果人们不想使用它们[虚拟账户]，那没关系。但 Ledger 不是一个会计工具；它是一个可以用于做会计的工具。因此，我相信虚拟账户扮演了其他非会计问题的人可能希望填补的角色。”

我尊重地表示不同意见。因此，Beancount 采取更激进的立场，明确避免支持虚拟过账。如果您强烈认为需要它们，您应该使用 Ledger。

### 数字和操作的精度<a id="numbers-and-precision-of-operations"></a>

Beancount、Ledger 和 HLedger 在如何内部表示数字以及在检查交易过账的平衡精度方面有所不同。

首先，关于数字的表示方式：Ledger [<u>使用有理数</u>](http://www.ledger-cli.org/3.0/doc/ledger3.html#Internal-Design)试图保持数学运算结果的全部精度。这是可行的，但[<u>我认为这也许不是最合适的选择</u>](https://groups.google.com/d/msg/ledger-cli/m-TgILbfrwA/YjkmOM3LHXIJ)。绝大多数情况下，发生的运算涉及从单位数和价格或成本转换为账户过账变化的总值（例如，单位数 x 成本 = 总成本）。我们表示交易信息的任务是复制大多数发生在机构中的运算。这些运算总是涉及单位和货币的舍入（银行确实应用随机舍入），从这些机构的角度来看，从政府的角度来看，*正确的*数字确实是*舍入*后的数字。这不是数学纯度的问题，而是实际问题，我们的系统应该做银行所做的。因此，我认为我们应该始终将舍入后的数字过账到账户。使用有理数在那种意义上不是一个限制，但我们必须小心在需要的地方存储舍入后的数字。我认为 Ledger 实现的方法是尽可能保持原始精度。

Beancount 选择[<u>十进制</u>](https://docs.python.org/3/library/decimal.html)数表示法来存储从输入解析的数字，其精度与它们的写入方式相同。这种方法和使用有理数一样存在同样的问题，即十进制数运算结果将当前存储为其全部精度（尽管是十进制）。诚然，我还没有在需要的地方应用显式量化，这将是正确的做法。必须设计一个方案，以推断自动量化运算后数字的适当精度。十进制表示法提供了运算后舍入的自然机会，并且是适合的选择，实现甚至通常为量化提供了一个上下文。还要注意的是，永远不需要以无限精度存储数字：机构本身从未这样做。

奇怪的是，HLedger[<u>为其价格选择“双精度”分数二进制表示</u>](https://groups.google.com/d/msg/ledger-cli/m-TgILbfrwA/iZAv6IK3KuYJ)。这是一个不幸的选择，比使用精确表示法更糟糕：用户输入的分数十进制数字*从未*由其相应的二进制形式精确表示。所以所有数字都是不正确的，但“足够接近”，总体上有效，唯一显示干净最终结果的方法是在报告时舍入到合适的位数。可以说，64 位双精度表示提供的大量位数不太可能导致显著错误，考虑到我们进行的操作数量……但二进制舍入误差可能会累积，基本上所有数字在内部都是不正确的，舍入到其最近的二进制亲属。既然我们的任务是会计，为什么不直接正确表示它们？

其次，在检查交易过账的平衡时，需要对这些金额允许一些容忍度。考虑到在文本文件中输入数字意味着有限的小数表示，这一点很明确。例如，如果您要乘以单位数和成本，例如都用 2 位小数表示，结果可能有 4 位小数，然后您需要将结果与通常用 2 位小数输入的现金金额进行比较。您需要以某种方式允许一些宽松。

系统在选择容忍度方面有所不同：

- Ledger 试图自动推导其余额检查所使用的精度，使用最近解析的上下文（按文件顺序）。所使用的精度是最近解析的特定商品的最后一个值的精度。这可能会导致[<u>交易之间不必要的副作用，难以调试</u>](https://groups.google.com/d/msg/ledger-cli/m-TgILbfrwA/cTHg2juqEJgJ)。

- 另一方面，HLedger 使用全局精度设置。[<u>首先处理整个文件，然后从整个输入文件中看到的最精确数字推导出精度</u>](https://groups.google.com/d/msg/ledger-cli/m-TgILbfrwA/SoGZDNhlDOkJ)。

- 目前，Beancount 在其余额检查算法中使用常数值（0.005 任何单位）作为容忍度。这很弱，至少应该是商品依赖的，如果不是账户依赖的。最终，这取决于表示特定过账使用的位数。我们有一个[<u>提案</u>](precision_tolerances.md)在途中修复此问题。

我计划修复此问题：Beancount 最终将使用完全*本地*于每个交易的方法推导其精度，也许有一个全局默认值（这仍在进行中——*2014 年 10 月*）。最精确位数的一半将是容忍度。这将类似于 HLedger 的方法推导，但针对每个交易单独进行。这将允许用户通过在输入中插入更多位数来使用任意精度。仅小数位数将用于推导精度。不应用任何交易对任何其他交易的平衡上下文的全局影响。没有交易应影响任何其他交易的平衡上下文。[<u>舍入误差将可选地累积到一个权益账户，如果您想监控它</u>](https://groups.google.com/d/msg/ledger-cli/m-TgILbfrwA/YjkmOM3LHXIJ)。

至于自动量化运算结果的数字，我仍需找出一种自动方法来实现。

### 交易级别的过滤<a id="filtering-at-the-transactional-level"></a>

系统之间的另一个差异是 Beancount 不支持过账级别的过滤，只支持交易级别的过滤。也就是说，在对输入数据应用过滤器时，即使过滤适用于过账的谓词，也只会产生*完整*交易的集合。这是为了生成过账总和精确为零的集合。我们不会仅忽略某些交易的过账。然而，一旦计算出所有余额，我们仍将允许报告删除任意账户子集。

Ledger 过滤工作在[<u>交易或过账级别</u>](https://groups.google.com/d/msg/ledger-cli/i2ouOXgyVbE/EyWEXqZDHmkJ)。我认为这令人困惑。我真的不明白为什么它会这样工作或它实际如何工作。

（请注意，这不是一个非常相关的点，因为我还没有实现自定义任意过滤；目前唯一可用的过滤是可以通过网络界面获得的“视图”，但我将很快提供一个简单的逻辑表达语言，以应用自定义过滤到解析的交易中，因为我认为这是一个强大的功能。直到最近，大多数报告只通过网络界面呈现，现在 Beancount 实现了控制台报告，这不是很需要。）

### 扩展机制<a id="extension-mechanisms"></a>

Beancount 和 Ledger 都提供了针对其数据集编写脚本的机制。这些机制都很有用，但不同。

Ledger 提供

- 一个自定义表达语言，用于解释以生成报告

- 一个将内容导出为 XML 的命令

- 一个将内容导出为 LISP 的命令

- 一个 Python 绑定库，提供对其 C++ 数据结构的访问

- *(其他？)*

（注意：由于其依赖项、使用的 C++ 特性和构建系统，我发现很难在我的普通 Ubuntu 机器或 Mac OS 计算机上构建 Ledger。构建带有 Python 绑定的版本更为困难。如果您有耐心、时间，这对您来说不是问题，那很好，但如果您能找到预打包版本，我建议您使用那个版本。）

Beancount [<u>提供</u>](beancount_scripting_plugins.md)

- 一个本地 Python 插件系统，允许您指定要导入和调用的 Python 模块列表，以过滤和转换解析的指令，以实现新功能；

- 一个易于加载的函数，允许您访问从解析和处理 Beancount 分类账中产生的内部数据结构。这也是一个本地 Python 库。

因此，基本上，您必须编写 Python 来扩展 Beancount。我计划提供 XML 和 SQL 的输出（由于我使用的简单数据结构，这些实现非常简单）。此外，使用 Beancount 自己的“打印机”模块生成的文本保证可以解析回相同的数据结构（Beancount 保证其语法和数据结构的回程）。

一个优点是插件系统允许您对生成的指令列表进行任意的流内转换，这是原型新功能和更简洁语法的好方法。例如，您可以分配一个特殊标签，将触发对这些标记交易的任意转换。这些模块不必集成到 Beancount 中：它们可以随意存在于您自己的 PYTHONPATH 上，因此您可以在不必向上游贡献新功能或修补源代码的情况下进行实验。

（注意：Beancount 用 Python 3 实现，因此您可能需要安装一个最新版本，例如 Python-3.4，如果没有。此时，Python 3 正在变得非常普遍，所以我认为这不是问题，但您可能使用较旧的操作系统。）

### 通过插件自动化交易<a id="automated-transactions-via-plugins"></a>

Ledger 提供了一种特殊语法，以[<u>基于某些匹配标准自动插入现有交易的过账</u>](http://ledger-cli.org/3.0/doc/ledger3.html#Automated-Transactions)。该语法允许用户访问过账的一些数据，如金额和账户名称。该语法专门允许应用交易和过账“标签”。

Beancount 允许您通过其插件扩展机制做到同样的事情甚至更多。您编写的插件能够完全修改、创建或删除任何对象和对象的任何属性，在解析交易流中允许您进行尽可能多的自动化和汇总。这不需要特殊语法——您只需在 Python 中工作，访问其所有功能——并且可以在现有语法的基础上进行自动化。一些示例在 `beancount.plugins.*` 下提供。

然而，有一种说法是，为了快速简便地指定最常见的仅添加一些过账的方法。我还没有完全信服，但 Beancount 最终可能会获得这个功能（如果您愿意，现在可以在插件文件中轻松原型化这个功能）。

### 不支持时间或生效日期<a id="no-support-for-time-or-effective-dates"></a>

Beancount 不表示交易的日内时间，其粒度为一天。Ledger 允许您将交易的时间精确到秒。我选择限制其范围，以简化问题，我还认为支持日内操作的用例很少。

请注意，虽然 Beancount 的最大分辨率为一天，但当它对指令进行排序时，它将保持一天内发生的所有交易的相对顺序，因此可以在 Beancount 中表示同一天发生的多笔交易并仍然进行正确的库存记账。但我相信，如果您进行日内交易，您需要一个更专业的系统来计算日内收益并进行技术分析和日内损益计算。Beancount 不适合这些（如果这是其范围，还需要很多其他功能）。

Ledger 还支持*生效日期*，这实际上是交易的备用日期。报告功能允许 Ledger 用户使用主日期或备用日期。我曾在 Beancount 中有这个功能，但我删除了它，主要是因为我不想引入报告选项，并且要处理两个日期，例如交易日期和结算日期，我希望强制在任何时间点，所有交易都平衡。我也从未多次使用过它，这表明它可能是多余的。处理在不同时间点发生的过账会导致不平衡，或者我将不得不提出一个涉及“过渡”或“转移”账户的解决方案。我更喜欢删除该功能：在 8 年的数据中，我*总是*能够调整日期以使一切平衡。这不是一个大问题。

请注意，处理这些拆分交易并将它们合并在一起将被处理；一个[<u>提案</u>](settlement_dates_in_beancount.md)正在进行中。

### 文件<a id="documents"></a>

Beancount 提供支持，将分类账的账户图表内容与文件目录层次结构集成在一起。您可以提供一个目录路径，Beancount 将自动找到并创建对应的 Document 指令，对于以日期开头的文件名，在镜像账户名称的目录中，将这些文件附加到这些账户上。通过一些配置，bean-file 工具可以自动归档下载的文件到这样的目录层次结构中。

Ledger 将文件绑定到交易的方式是通过通用元数据。用户可以将任意键值对附加到他们的交易上，这些可以是文件名。除此之外，没有特定的文件组织支持。

### 更简单和更严格<a id="simpler-and-more-strict"></a>

最后，Beancount 的输入语法总体上比 Ledger 更简单。命令行选项很少——这是有意为之的，我希望将所有输入都本地化在文件中——指令语法更加统一：所有交易都以日期和关键字开头。如果简单性的论点对您有吸引力，您可能更喜欢使用 Beancount。我觉得 Ledger 提供的选项数量令人望而生畏，我不能声称理解所有这些选项可能的交互方式。如果这不担心您，您可能更喜欢使用 Ledger。

它也比 Ledger 更严格。某些类型的 Beancount 输入无效。例如，任何账户中的交易都需要有一个开放指令以启动账户（尽管某些约束可以通过可选插件放松）。如果您维护一个 Beancount 分类账，您可以预期需要规范化它，以修复报告的许多常见错误。我认为这是好事：它检测到许多潜在问题，并对其输入应用许多严格的约束，使我们在处理指令流时能够做出合理的假设。如果您不关心精度或检测潜在错误，Ledger 将允许您更加自由。然而，如果您希望生成精确无误的交易记录，Beancount 在验证输入方面提供了更多支持。

### 网络界面<a id="web-interface"></a>

Beancount 有一个内置的网络界面，还有一个名为[<u>Fava</u>](https://github.com/beancount/fava)的外部项目，显著改进了相同的主题。这是浏览报告的默认模式。我相信 HLedger 也有一个网络界面。

## 缺失的功能<a id="missing-features"></a>

Beancount 一般试图*最小化*其提供的功能数量。这与 Ledger 的实现形成对比，Ledger 实现了大量功能，以实验双重记账方法。有大量选项。这反映了一种不同的方法：我相信存在一个小的核心必要功能，当我们能够最小化并移除任何不严格必要的功能时，前进的步伐才会更快。我的目标是提供最小可能的核心功能，允许一个人进行全谱会计活动，并使用户能够扩展系统以自动化重复的语法。

但以下是 Beancount 不支持而 Ledger 支持的功能列表，我认为这些功能最终会很好。以下列表不太可能是详尽的。

### <s>控制台输出</s><a id="console-output"></a>

<s>Beancount 的最初实现侧重于为其内容提供网络视图。在 2.0 重写期间，我开始实现一些控制台/文本输出，主要是因为我希望能够将报告导出与他人共享。我有一个试算平衡视图（如 Ledger 的“bal”报告），但目前没有实现日记账视图。</s>

<s>另一方面，Ledger 一直专注于控制台报告。</s>

<s>在初次发布后，我将首先使 Beancount 的所有报告支持输出到文本格式，因为我越来越喜欢文本报告。使用 bean-query --list-formats 查看当前状态。</s>

### <s>过滤语言</s><a id="filtering-language"></a>

<s>Beancount 目前还没有过滤语言。直到最近，其网络界面是呈现报告和探索分类账内容的主要模式，它提供了“视图”的形式，有限的交易子集，例如每年、每个标签等。具有过滤语言尤其允许去掉许多子账户。我想简化我的账户图表，因此需要这个功能。</s>

<s>我正在添加一个简单的逻辑表达语言，以对 Beancount 交易集合进行任意过滤。这很容易实现，是高优先级任务。</s>

### <s>无元数据</s><a id="no-meta-data"></a>

<s>Beancount 目前不支持元数据。Ledger 用户经常自由使用元数据。这已被识别为一个强大的功能，并已原型实现。元数据将在任何指令类型以及任何过账上支持。每个对象将附加一对键值对。支持的值将包括字符串、日期、数字、货币和金额。</s>

<s>到目前为止，计划是严格不在 Beancount 自己的代码中使用元数据，故意的。元数据将严格提供给用户插件和自定义用户脚本使用。</s>

### <s>无算术表达式</s><a id="no-arithmetic-expressions"></a>

<s>Beancount 不支持在输入中允许数字的地方进行任意表达式计算。Ledger 支持这些。我还没有需要这些的用途，但我没有特别反对添加这个功能，我只是没有实现它，因为我自己不需要。</s>

<s>我认为实现会很简单，非常低风险，只需对解析器进行简单更改，并且已经有一个回调用于数字。我认为有很多合法用途。</s>

### 对 Unicode 的支持有限<a id="limited-support-for-unicode"></a>

Beancount 支持 UTF8 或其他编码***仅在字符串中***（即，在引号中的输入）。例如，您可以使用非 ASCII 字符输入收款人和说明，但不能用于账户名称（不在引号中）。Ledger 支持整个文件的其他编码。

Beancount 缺乏更广泛的编码支持的原因是目前的标记工具限制。我一直在使用[<u>GNU flex</u>](https://www.gnu.org/software/flex/)实现我的词法分析器，它不支持任意编码。我只需要[<u>编写一个更好的词法分析器</u>](https://groups.google.com/d/msg/ledger-cli/C6GOOj8kGtQ/Jt9jMdRQIH4J)，并使其与[<u>Bison</u>](http://www.gnu.org/software/bison/)配合使用，这并不困难。我最终会手动编写自己的词法分析器——这有其他优势——并将其编写为支持 Unicode（Python 3 完全支持这点，因此只需修改词法分析器，这是一个简单的编译单元）。这是一项相对容易且独立的任务。

### 无预测或定期交易<a id="no-forecasting-or-periodic-transactions"></a>

Beancount 没有支持生成定期交易进行预测，尽管有一个插件提供了一个简化版本，作为插件工作原理的示例（见 `beancount.plugins.forecast`）。Ledger 支持[<u>定期交易生成</u>](http://www.ledger-cli.org/3.0/doc/ledger3.html#Periodic-Transactions)。

我确实想最终将此添加到核心 Beancount 中，但我想在实现之前清楚地定义语义。更新分类账本质上是复制和复制发生在其他地方的交易数据。我不认为常规交易在现实中是那么“常规的”；根据我的经验，现实交易中总是有一些小的变化，使得无法通过生成器自动生成一系列交易，以使用户能够放弃逐一更新它们。在我看来，它的用途是在生成*暂定*未来交易。我强烈认为这些交易应仅限于不跨越已对账的历史，并且已对账的历史应替代任何自动生成的交易。

我对实现此功能有一些相当完整的想法，但目前我不使用预测，因此它在后备计划中。虽然理论上可以使用 Ledger 的定期交易进行预测，但为了*精确*表示账户历史，您可能需要每次向账户添加新交易时调整这些交易的开始日期并替换预测交易。我认为 Ledger 中自动交易的当前语义在创建账户内容近似值之外不是很有用。

（同时，鉴于使用插件扩展 Beancount 的容易性，我建议您现在自己开始实验预测交易，如果我们能够得出一个通用的方法来创建它们，我愿意将其合并到主代码中。）
